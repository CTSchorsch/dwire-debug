char UsbSerialPortName[32];  // Currently selected port.
int  SerialBaud;
int BreakLength;


#ifdef windows

  char *LoadDosDevices() {
    char *DosDevices = 0;
    int   size       = 24576;
    int   used       = 0;
    while (1) {
      DosDevices = Allocate(size);
      used = QueryDosDevice(0, DosDevices, size);
      if (used) {break;}
      int error = GetLastError();
      Free(DosDevices);
      DosDevices = 0;
      if (error != ERROR_INSUFFICIENT_BUFFER) {break;}
      size *= 2;
    }
    return DosDevices;
  }

  void FindSerials() {
    char *DosDevices = LoadDosDevices();
    char *CurrentDevice = DosDevices;

    while (*CurrentDevice) {
      if (strncmp("COM", CurrentDevice, 3) == 0) {
        Assert(PortCount < countof(Ports));
        Ports[PortCount] = malloc(sizeof(struct SPort));
        Assert(Ports[PortCount]);
        Ports[PortCount]->kind = 's';
        Ports[PortCount]->index = strtol(CurrentDevice+3, 0, 10);
        Ports[PortCount]->character = -1;              // Currently undetermined
        ((struct SPort*)Ports[PortCount])->handle = 0; // Currently unconnected
        ((struct SPort*)Ports[PortCount])->baud   = 0; // Currently unconnected
        PortCount++;
      }
      while (*CurrentDevice) {CurrentDevice++;}  // Skip over device string
      CurrentDevice++;                           // SKip over one zero terminator
    }

    Free(DosDevices);
  }

#else

  void FindSerials() {
    DIR *DeviceDir = opendir("/dev");
    if (!DeviceDir) {return;}}

    struct dirent *entry = 0;
    while ((entry = readdir(DeviceDir)))) {
      if (!strncmp("ttyUSB", entry->d_name, 6)) {
        Assert(PortCount < countof(Ports));
        Ports[PortCount] = malloc(sizeof(struct SPort));
        Assert(Ports[PortCount]);
        Ports[PortCount]->kind = 's';
        Ports[PortCount]->index = strtol(entry->d_name+6, 0, 10);
        Ports[PortCount]->character = -1;              // Currently undetermined
        ((struct SPort*)Ports[PortCount])->handle = 0; // Currently unconnected
        ((struct SPort*)Ports[PortCount])->baud   = 0; // Currently unconnected
        PortCount++;
      }
    }
    closedir(DeviceDir);
  }

#endif


void SerialSendBytes(const u8 *out, int outlen) {
  Write(SerialPort, out, outlen);
  // Since txd and rxd share the same line, everything we transmit will turn
  // up in the receive buffer (unless there is a collision). Drain this
  // echoed input and check that it has not been changed.
  u8 actual[outlen];
  SerialRead(SerialPort, actual, outlen);
  for (int i=0; i<outlen; i++) {
    if (actual[i] != out[i]) {
      Ws("WriteDebug, byte "); Wd(i+1,1); Ws(" of "); Wd(outlen,1);
      Ws(": Read "); Wx(actual[i],2); Ws(" expected "); Wx(out[i],2); Wl(); Fail("");
    }
  }
}

// Buffer accumulating debugWIRE data to be sent to the device to minimize
// the number of USB transactions used,

u8   SerialOutBufBytes[256];
int  SerialOutBufLength = 0;

void SerialFlush() {
  if (SerialOutBufLength > 0) {
    SerialSendBytes(SerialOutBufBytes, SerialOutBufLength);
    SerialOutBufLength = 0;
  }
}

void SerialSend(const u8 *out, int outlen) {
  while (SerialOutBufLength + outlen >= sizeof(SerialOutBufBytes)) {
    // Total (buffered and passed here) meets or exceeds SerialOutBuf size.
    // Send buffered and new data until there remains between 0 and 127
    // bytes still to send in the buffer.
    int lenToCopy = sizeof(SerialOutBufBytes)-SerialOutBufLength;
    memcpy(SerialOutBufBytes+SerialOutBufLength, out, lenToCopy);
    SerialSendBytes(SerialOutBufBytes, sizeof(SerialOutBufBytes));
    SerialOutBufLength = 0;
    out += lenToCopy;
    outlen -= lenToCopy;
  }
  Assert(SerialOutBufLength + outlen <= sizeof(SerialOutBufBytes));
  memcpy(SerialOutBufBytes+SerialOutBufLength, out, outlen);
  SerialOutBufLength += outlen;
  // Remainder stays in buffer to be sent with next read request, or on a
  // SerialFlush call.
}



int SerialReceive(u8 *in, int inlen) {
  SerialFlush();
  SerialRead(SerialPort, in, inlen);
  return inlen;
}




int MaybeReadByte() {
  u8 byte = 0;
  int bytesRead;

  bytesRead = Read(SerialPort, &byte, 1);
  if (bytesRead == 1) return byte; else return -1;
}

int GetSyncByte(int verbose) {
  int byte  = 0;

  byte = MaybeReadByte();
  if (byte < 0) {Fail("Expecting break byte 0x00, but no bytes read.");}
  else if (byte != 0) {Ws("Warning, expected to read zero byte after break, but got $"); Wx((u8)byte,2); Fail(".");}

  if (verbose) Ws(", skipping [");
  if    (byte == 0)    {if (verbose) Wc('0'); byte = MaybeReadByte();} // Skip zero bytes generated by break.
  if    (byte == 0)    {if (verbose) Wc('0'); byte = MaybeReadByte();} // Skip zero bytes generated by break.
  if    (byte == 0)    {if (verbose) Wc(']'); return 0;}               // This many zeroes means we're very much faster than the chip
  while (byte == 0xFF) {if (verbose) Wc('F'); byte = MaybeReadByte();} // Skip 0xFF bytes generated by line going high following break.
  if (verbose) Ws("]");

  return byte;
}



void Wbits(int byte) {
  if (byte < 0) {Wd(byte,1);}
  else for (int i=7; i>=0; i--) {Wc(((byte >> i) & 1) ? '1' : '0');}
}




int scaleby(int byte) {
  // Return amount to adjust baudrate by before the next test.
  // The scale is returned as a percentage.
  // E.g. Returns 95 to suggest a reduction by 5%.
  // Returns 100 only when the byte is exactly as expected.

  if (byte == 0x55) return 100;
  if (byte == 0   ) return 20;

  int lengthcount[9] = {0}; // Number of runs of each length

  int i = 7;
  while (((byte >> i) & 1) && (i > 1)) i--;  // Ignore leading ones as they likely come from preceeding stop bits.

  int remaining = i+1;      // Number of remaining bits we have to work with.

  int c = (byte >> i) & 1;  // Current bit value
  int s = i;                // Start of current run
  while (i > 0) {
    i--;
    int b = (byte >> i) & 1;
    if (b != c) {           // Change of line polarity
      lengthcount[s-i]++;
      c = b;
      s = i;
    }
  }
  lengthcount[s+1]++; // Length of final run

  if (Verbose) {
    Ws(": "); Wd(remaining,1); Wc(' ');
    for (int j=0; j<9; j++) Wd(lengthcount[j],1);
  }

  // If all of the remaining bits are 0, it means the first '0' bit of the
  // actual 01010101 response is at least that wide at the current baud clock.

  int remainingmask = (1<<(remaining))-1;

  if ((byte & remainingmask) == 0) // Other than leading '1's, all bits are '0'
    switch(remaining) {
      case 1:  return 20;
      case 2:  return 20;
      case 3:  return 20;
      case 4:  return 30;
      case 5:  return 40;
      case 6:  return 60;
      default: return 95;
    }

  // Now interpret run lengths
  if (lengthcount[3] > 1) return 60; // There are at least 2 runs 3 bits wide
  if (lengthcount[2] > 1) return 85; // There are at least 2 runs 2 bits wide
  if (lengthcount[1] > 1) return 95; // at least two runs just 1 bit long, we're very close.
  if (lengthcount[4])     return 40; // There is a 4 bit run
  if (lengthcount[5])     return 30; // There is a 6 bit run
  if (lengthcount[6])     return 25; // There is a 7 bit run
  if (lengthcount[7])     return 25; // There is a 8 bit run

  return 95;  // Only short runs, we're very close
}




int TryBaudRate(int baudrate) {
  // Returns: > 100 - approx factor by which rate is too high (as multiple of 10)
  //          = 100 - rate generates correct 0x55 response
  //          = 0   - port does not support this baud rate

  if (Verbose) {
    Ws("Trying ");          Ws(UsbSerialPortName);
    Ws(", baud rate ");     Wd(baudrate, 6);
    Ws(", break length ");  Wd(BreakLength, 4);
  } else {
    Wc('.');
  }
  Wflush();
  MakeSerialPort(UsbSerialPortName, baudrate, &SerialPort);
  if (!SerialPort) {
    Vsl(". Cannot set this baud rate, probably not an FT232.");
    return 0;
  }

  SerialBreak(SerialPort, BreakLength);
  int byte = GetSyncByte(Verbose);

  Close(SerialPort);
  SerialPort = 0;

  if (byte < 0) {
    Wsl(", No response, giving up."); return 0;
  } else if (Verbose) {
    Ws(", received "); Wbits(byte);
  }

  int scale = scaleby(byte);
  if (scale == 100) Vsl(": expected result.");
  return scale;
}




int FindBaudRate() {

  int baudrate = 150000; // Start well above the fastest dwire baud rate based
                         // on the max specified ATtiny clock of 20MHz.
  BreakLength  = 50;     // 50ms allows for clocks down to 320KHz.
                         // For 8 MHz break len can be as low as 2ms.

  // First try lower and lower clock rates until we get a good result.
  // The baud rate for each attempt is based on a rough measurement of
  // the relative size of pulses seen in the byte returned after break.

  int scale = TryBaudRate(baudrate);
  if (scale == 0) {return 0;}

  while (scale != 100) {
    Vs(", scale "); Vd(scale,1); Vsl("%");
    baudrate = (baudrate * scale) / 100;
    scale = TryBaudRate(baudrate);
  }

  if (scale == 0) return 0;

  // We have hit a baudrate that returns the right result this one time.
  // Now find a lower and upper bound of working rates in order to
  // finally choose the middle rate.

  BreakLength = 100000 / baudrate; // Now we have the approx byte len we can use a shorter break.
  if (BreakLength < 2) BreakLength = 2;

  Vsl("Finding upper bound.");
  int upperbound = baudrate;
  do {
    int trial = (upperbound * 102) / 100;
    scale = TryBaudRate(trial);
    if (scale == 100) upperbound = trial;
  } while (scale == 100);
  Vl();

  Vsl("Finding lower bound.");
  int lowerbound = baudrate;
  do {
    int trial = (lowerbound * 98) / 100;
    scale = TryBaudRate(trial);
    if (scale == 100) lowerbound = trial;
  } while (scale == 100);
  Vl();

  // Finally open the port with the middle of the working range and check
  // it actually works.

  return (lowerbound + upperbound) / 2;
}




void TryConnectSerialPort(int baud) {
  jmp_buf oldFailPoint;
  memcpy(oldFailPoint, FailPoint, sizeof(FailPoint));
  SerialPort = 0;
  SerialBaud = 0;

  if (setjmp(FailPoint)) {
    SerialPort = 0;
    SerialBaud = 0;
  } else {
    if (baud <= 0) {SerialBaud = FindBaudRate();}
    if (SerialBaud) {
      BreakLength = 100000 / SerialBaud;
      MakeSerialPort(UsbSerialPortName, SerialBaud, &SerialPort);
      SerialBreak(SerialPort, BreakLength);
      int byte = GetSyncByte(0);
      if (byte != 0x55) {Close(SerialPort); SerialPort = 0;}
    }
    //  if (SerialPort) {
    //    Ws("Connected to DebugWIRE device on USB serial port "); Ws(UsbSerialPortName);
    //    Ws(" at SerialBaud rate "); Wd(SerialBaud, 1); Wl();
    //    DwConnect();
    //  }
  }

  memcpy(FailPoint, oldFailPoint, sizeof(FailPoint));
}




//  // Implement ConnectSerialPort called from DwPort.c
//  void Serial_Open(char *portname, int baud) {
//    SerialPort = 0;
//    UsbSerialPortName = portname;
//    TryConnectSerialPort(baud);
//    if (!SerialPort) {Ws("Couldn't connect to DebugWIRE device on "); Fail(UsbSerialPortName);}
//  }


int SerialReadByte() {
  u8 byte = 0;
  int result;
  while ((result = Read(SerialPort, &byte, 1)) == 0) {Wc('n'); Wflush();}
  if (result<0) {Ws("SerialReadByte received error "); Wd(result,1); Fail(" from Read() on SerialPort.");}
  return byte;
}

void SerialSync() {
  u8 byte = 0;

  SerialFlush();
  while ((byte = SerialReadByte()) == 0x00) {}    // Eat 0x00 bytes generated by line at break (0v)
  while (byte == 0xFF) {byte = SerialReadByte();} // Eat 0xFF bytes generated by line going high following break.
  if (byte != 0x55) {
    Ws("Didn't receive 0x55 on reconnection, got "); Wx(byte,2); Wsl(".");
    Wsl("Clock speed may have changed, trying to re-sync.");
    CloseHandle(SerialPort);
    TryConnectSerialPort(0);
    if (!SerialPort) {Ws("Couldn't reconnect to DebugWIRE device on "); Fail(UsbSerialPortName);}
  }
}

void SerialBreakAndSync() {
  //  Wsl(" -- SerialBreakAndSync starting.");
  Assert(SerialOutBufLength == 0);
  BreakLength = 100000 / SerialBaud;
  //  Wsl(" -- SerialBreakAndSync calling SerialBreak.");
  SerialBreak(SerialPort, BreakLength);
  //  Wsl(" -- SerialBreakAndSync calling SerialSync.");
  SerialSync();
  //  Wsl(" -- SerialBreakAndSync complete.");
}

void SerialWait() {SerialFlush();}


void SelectSerialHandlers() {
  DwBreakAndSync = SerialBreakAndSync;
  DwSend         = SerialSend;
  DwFlush        = SerialFlush;
  DwReceive      = SerialReceive;
  DwSync         = SerialSync;
  DwWait         = SerialWait;
}


void ConnectSerialPort(struct SPort *p) {
  Assert(p->port.kind == 's');
  SelectSerialHandlers();

  #if windows
    snprintf(UsbSerialPortName, sizeof(UsbSerialPortName), "COM%d", p->port.index);
  #else
    snprintf(UsbSerialPortName, sizeof(UsbSerialPortName), "/dev/ttyUSB%d", p->port.index);
  #endif

  Ws(UsbSerialPortName); Ws(" ");
  if (p->handle) {
    SerialPort = p->handle;
    SerialBaud = p->baud;
    SerialBreakAndSync();
  } else {
    TryConnectSerialPort(p->baud);
    p->handle = SerialPort;
    p->baud   = SerialBaud;
  }
  //  Ws(" -- SerialPort $"); Wx((int)SerialPort,1); Wl();
  Ws("\r                                        \r");
  if (!SerialPort) p->port.kind = 0; // Couldn't use this port
}